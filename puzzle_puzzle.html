<!DOCTYPE html>
<html>
<head>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js">
</script>
<script>


/*
	iWatch Mode
	gameMode = 2
	3x3
	kindOfNumber = 4
	clickOnce = true
*/

/*
	추가 게임 요소
	1. 힌트 시스템
	2. 특정 수 파괴
	3. 거꾸로 변환
	4. 흑백
	5. 폭탄
	6. 한개씩 변환 (game mode 1)
	7. 한꺼번에 변환 (game mode 3)


*/

/*
	gameMode=0	// 한개씩 바꾸기
		kindOfNumber = 4, clickOnce = true	// 재미 x, 콤보 x,
		kindOfNumber = 4, clickOnce = false // 재미 x,

	gameMode=1	// 같은 숫자 모두 바꾸기
		kindOfNumber = 5, clickOnce = true	// 재미*, No more change 가 발생하므로 퍼즐성이 있음
		kindOfNumber = 6, clickOnce = true	// 재미x, No more change 가 발생하므로 퍼즐성이 강함

	gameMode=2	// 인접한 같은 숫자 바꾸기
		kindOfNumber = 4, clickOnce = true	// 재미***, 난이도*** 콤보 ***, 순발력 필요, 적절한 콤보로 중독성 있음
		kindOfNumber = 4, clickOnce = false	// 재미****, 난이도** 콤보 ***
		kindOfNumber = 5, clickOnce = true	// 재미*, 리듬감이 떨어지며 어렵다
		kindOfNumber = 5, clickOnce = false	// 재미*, 우연성 ***

	gameMode=3	// 제일 높은 숫자만 터짐
		kindOfNumber = 4, clickOnce = true	// 재미**, 폭탄 크게 터트리기 류의 전혀 다른 게임 가능성 있음
		kindOfNumber = 5, clickOnce = true	// 재미*, 어려움
*/

var gameMode = 2;
var gameTime = 60;
var puzzleMode = true;
var appleWatchMode = true;//3x3 // puzzle
var width = 7;
var height = 7;
var kindOfNumber = 4;//4;
var minOfComplete = 3;
var gameTimeResetEveryClick = false;
var clickOnce = true;
var regenBlock = true;
var dropBlock = true;
var onetimeGrow = false;
var rotation = true;
//var disableChained = true;

var buttonWidth = 60;//60;
var buttonHeight = 60;//buttonWidth;

var remainTime = gameTime;
var remainTimeTid;

var finalFlag = false;	// 2015.08.05 추가
						// 타임 오버 후에 콤보가 연속되는 동안은 게임이 끝나지 않는다.
						// 파이널 팡과 같은 모드로 최고 득점의 한계를 없도록 만들어 준다

var alwaysHint = false;

var inputEnable = true;
var clickDelay = 100;
var aniState = 0;
var aniDelay = 100;
var animateTid;

var comboTiming = 1500;	// TODO 콤보 타이밍은 피버 단계에 따라 줄어들게 할 것(2초 -> 1.5초 -> 1.2초 -> 1초)	2016.08.05
var comboTimingTid;

var map = new Array(height);
var hintMap = new Array(height);
var clear = new Array(height);
var clicked = new Array(height);

var tilePath = "chicken/";
var tileText = ["<img src='"+tilePath+"0_0.png'/>", "<img src='"+tilePath+"1_0.png'/>", "<img src='"+tilePath+"2_0.png'/>", "<img src='"+tilePath+"3_0.png'/>"];
var tileClickedText = ["<img src='"+tilePath+"0_1.png'/>", "<img src='"+tilePath+"1_1.png'/>", "<img src='"+tilePath+"2_1.png'/>", "<img src='"+tilePath+"3_1.png'/>"];
//var tileText = ["<h1>1</h1>", "<h1>2</h1>", "<h1>3</h1>", "<h1>4</h1", "<h1>5</h1>"];
//var tileClickedText = ["<h1>1</h1>", "<h1>2</h1>", "<h1>3</h1>", "<h1>4</h1", "<h1>5</h1>"];

//var tileText = ["달걀", "병아리", "닭", "치킨"];
//var color = ["Red", "Orange", "Green", "Aqua", "Blue","Chartreuse","Violet","Cyan","White"];
var color = ["LightCyan", "Yellow", "Orange", "Pink", "#c00000","#d00000","#e00000","#f00000","white"];
//var color = ["LightCyan", "LightCyan", "LightCyan", "LightCyan", "#c00000","#d00000","#e00000","#f00000","white"];
var blankNumber = kindOfNumber;
var blankColor = "White";
var clickedColor = "Grey";
var hintColor = "Cyan";

var itemCode = [20, 21, 22, 23, 24];
var itemText = ["수탉", "촉진제", "???", "부화기", "폭탄"];
var itemChance = [3, 1, 2, 3, 5];	// 천분율, combo에 의해 아이템을 만들때는 각 아이템의 출현 비율이 된다.
//var itemChance = [0, 0, 10, 0, 0, 0];	// 천분율, combo에 의해 아이템을 만들때는 각 아이템의 출현 비율이 된다.
var itemColor = ["Chartreuse", "Chartreuse", "Chartreuse", "Chartreuse", "Chartreuse","Chartreuse"];
var itemCreationTimingForCombo = [10,25,45,70,100,135,175,220];
//var itemCreationTimingForCombo = [5,10,15,20,60,80,100];
var feverLevel = 0;
var itemCreationFlag = false;
var hintFlag = alwaysHint;
var hintTimerTid;
var itemApplied = false;
var itemForChunkAmount = [blankNumber,blankNumber,blankNumber,blankNumber,blankNumber,blankNumber,blankNumber,blankNumber,blankNumber,24, 24];	//	깨지는 갯수에 따른 아이템	7x8용
//var itemForChunkAmount = [blankNumber,blankNumber,blankNumber,blankNumber,blankNumber,blankNumber,blankNumber,blankNumber,blankNumber,24];	//	깨지는 갯수에 따른 아이템	8x8용


var itemChanceMax = 0;	// 아이템 출현 확률 중 제일 큰 것
var itemChanceTotal = 0;	// 각 아이템 출현 확률의 합
var itemPortion = new Array(itemCode.length);	// 각 아이템 출현 확률이 전체 확률에서 차지하는 비중

var lastClickX, lastClickY;

var score = 0;
var lastEarnedScore = 0;
var combo = 0;
var maxComboOnGame = 0;

var highScore = 0;
var maxCombo = 0;
var maxFever = 0;

var seq = 0;
var seqMax = 0;

$(document).ready(function(){

	color[kindOfNumber] = blankColor;

/*	for( i = 0; i < itemChance.length; i++) {
		itemChanceTotal += itemChance[i];
		itemPortion[i] = itemChanceTotal;
		if( itemChance[i] > itemChanceMax )
			itemChanceMax = itemChance[i];
	}
*/

	if( appleWatchMode == true ) {
		gameMode = 2;
		gameTime = 0;
		width = 3;
		height = 3;
		kindOfNumber = 4;//4;
		minOfComplete = 3;
		gameTimeResetEveryClick = false;
		clickOnce = true;
		regenBlock = false;
		dropBlock = true;
		onetimeGrow = false;
		//var disableChained = true;
		rotation = true;
	}
		
	for( i = 0; i < height; i++){
		$("#game").append("<tr id='tr"+i+"'>");
		for( j = 0; j < width; j++) {
			var id = Math.floor(i * width + j);
			$("#tr"+i).append("<td align=center id='"+id+"' width="+buttonWidth+" height="+buttonHeight+"></td>");
			//$("#tr"+i).bind("click", function(){ alert('버튼 클릭됨'); });
		}
		$("#game").append("</tr>");
	}

	var id = initGame(0, 0)
	$("#mapid").attr("value", id);
	$("#clickmap").attr("value", 0);
	
	$("#random").click( function() {
		clearInterval(animateTid);
		clearInterval(remainTimeTid);

		id = initGame(0, 0);
		$("#mapid").attr("value", id);
		$("#clickmap").attr("value", 0);
	})
	
	$("#generate").click( function() {
		var id = $("#mapid").val();
		var click = $("#clickmap").val();

		if( id == undefined || id.length == 0) {
			id = 0;
		}
		id = id | 0;

		if( click == undefined || click.length == 0) {
			click = 0;
		}
		click = Number(click);

		clearInterval(animateTid);
		clearInterval(remainTimeTid);

		id = initGame(id, click);
		//$("#mapid").attr("value", id);
	})

	$("td").click( function(){
		if( inputEnable == false )
			return;

		if( finalFlag == true && combo == 0 )
		{
			return;
		}

		if( remainTime < 0 )
		{
			finalFlag = true;
			comboTiming = 1000;
		}


		lastEarnedScore = 0;

		var id = $(this).attr("id");
		var i = Math.floor(id / width);
		var j = Math.floor(id % width);

		if( map[i][j] == blankNumber ) 
			return;
		if( clicked[i][j] != 0 )
			return;

		if( rotation == false )
			if( map[i][j] == (kindOfNumber -1 ) )
				return;

		if( gameTimeResetEveryClick == true )
			remainTime = gameTime;

		itemApplied = false;
		
		if( puzzleMode) {
			for( var x = 0; x < width; x++ ) {
				for( var y = 0; y < height; y++ ) {
					if( clicked[y][x] != 0 ) {
						clicked[y][x]--;
					}
				}
			}
		}

		if( map[i][j] >= itemCode[0] ) {
			applyItem(j, i);
			itemApplied = true;
		}
		else if( gameMode == 0 ) {
			increaseOneTile(i,j);
		}
		else if( gameMode == 1 ) {
			increaseWholeTile(map[i][j]);
		}
		else if( gameMode == 2 ) {
			increaseChainedTile(i,j,map[i][j]);
			lastClickX = j;
			lastClickY = i;
		}
		else if( gameMode == 3 ) {
			if(map[i][j] == ( kindOfNumber - 1 ) )
				clearChainedTile(i,j,map[i][j]);
			else
				increaseChainedTile(i,j,map[i][j]);
		}

		//if(clickOnce == true )
		//	clicked[i][j] = 1;

		updateTile();

		inputEnable = false;
		aniState = 0;
		//setTimeout("animate()", 500);

		setTimeout("waitClickDelay()", clickDelay );
		//setTimeout("decrease()", 2000);

	});
	
});

function clearHint()
{
	var i,j;
	for(i=0;i<height;i++){
		for(j=0;j<width;j++){
			hintMap[i][j] = 0;
		}
	}
}

function markHint(x,y,number,count)
{
	if( x < 0 || x >= height )
		return count;
	if( y < 0 || y >= width )
		return count;

	if( hintMap[x][y] != 0 )
		return count;

	if( map[x][y] == number )
	{
		if( clicked[x][y] != 0 )	// clicked 는 clear하지 않으므로 1 이외의 값은 undefined 이다.
			hintMap[x][y] = 2;
		else {
			count++;
			hintMap[x][y] = 1;
		}
	}
	else
		return count;

	count = markHint(x-1,y,number,count);
	count = markHint(x+1,y,number,count);
	count = markHint(x,y-1,number,count);
	count = markHint(x,y+1,number,count);
	return count;
}

/*
	TODO 추가할 것.
	0 0 1 과 같은 형태(먼저 나온 것 눌러야 하는 경우)
	1 0 1 과 같은 형태(가운데 눌러야 하는 경우)

*/

function makeHint()
{
	var i,j;
	var prev, count;
	var prev2;
	for(i = 0; i < height; i++)	{
		count = 1;
		prev = -1;
		prev2 = -1;
		for(j = 0; j < width; j++) {
			if( count >= minOfComplete - 1 ) {
				if( map[i][j] + 1 == prev ) {
					clearHint();
					if( markHint(i,j,map[i][j],0) > 0 )
						return;
				}
			}
			if( map[i][j] == prev )
				count++;
			else
				count = 1;

			if( count >= minOfComplete - 1 ) {
				var comp = (map[i][j] + 1)%kindOfNumber;
				if( comp == prev2 ) {
					clearHint();
					if( markHint(i,j,map[i][j],0) > 0 )
						return;
				}
			}

			prev2 = prev;
			prev = map[i][j];
		}
	}
			
	for(j = 0; j < width; j++)	{
		count = 1;
		prev = -1;
		prev2 = -1;
		for(i = 0; i < height; i++) {
			if( count >= minOfComplete - 1 ) {
				if( map[i][j] + 1 == prev ) {
					clearHint();
					if( markHint(i,j,map[i][j],0) > 0 )
						return;
				}
			}
			if( map[i][j] == prev )
				count++;
			else
				count = 1;

			if( count >= minOfComplete - 1 ) {
				var comp = (map[i][j] + 1)%kindOfNumber;
				if( comp == prev2 ) {
					clearHint();
					if( markHint(i,j,map[i][j],0) > 0 )
						return;
				}
			}

			prev2 = prev;
			prev = map[i][j];
		}
	}
}

function waitClickDelay()
{
		animateTid = setInterval("animate()", aniDelay);
}

function applyItem(x,y)
{
	var i,j;
	var itemIndex = map[y][x] - itemCode[0];

	if( itemText[itemIndex] == '수탉' ) {	// %3	출산 3 -> 0
		for( i = 0; i < height; i++) {
			for( j = 0; j < width; j++) {
				if( map[i][j] < itemCode[0] )	// 아이템이 아니면
					map[i][j] = map[i][j] % 3;
			}
		}
	}
	else if( itemText[itemIndex] == '퇴행' ) {	// %2 퇴행 2 -> 0, 3 -> 1
		for( i = 0; i < height; i++) {
			for( j = 0; j < width; j++) {
				if( map[i][j] < itemCode[0] )	// 아이템이 아니면
					map[i][j] = map[i][j] % 2;
			}
		}
	}
	else if( itemText[itemIndex] == '촉진제' ) {	// 성장 +1, 3->클리어
		for( i = 0; i < height; i++) {
			for( j = 0; j < width; j++) {
				if( map[i][j] < itemCode[0] ) {	// 아이템이 아니면
					map[i][j] = map[i][j] + 1;
					if( map[i][j] == blankNumber ) {
						clear[i][j] = 1;	// 콤보 처리를 위해
						clicked[i][j] = 0;	// 표시 오류 방지
					}
				}
			}
		}
	}
	else if( itemText[itemIndex] == '???' ) {	// ???	힌트
		hintFlag = true;
		clearTimeout(hintTimerTid);
		hintTimerTid = setTimeout("hintTimer()", 5000 );
	}
	else if( itemText[itemIndex] == '부화기' ) {	// 부화 0 -> 1
		for( i = 0; i < height; i++) {
			for( j = 0; j < width; j++) {
				if( map[i][j] < itemCode[0] )	// 아이템이 아니면
					if( map[i][j] == 0 )
						map[i][j] = 1;
			}
		}
	}
	else if( itemText[itemIndex] == '알로' ) {	// 3x3 영역을 알로 변경
		for( i = y-1<0?0:y-1; i <= y+1 && i < height; i++) {
			for( j = x-1<0?0:x-1; j <= x+1 && j < width; j++) {
				//if( map[i][j] < itemCode[0] )	// 아이템이 아니면
						map[i][j] = 0;
			}
		}
		return;	// 클리어 하지 않는다
	}
	else if( itemText[itemIndex] == '폭탄' ) {	// 3x3 영역을 지움
		for( i = y-1<0?0:y-1; i <= y+1 && i < height; i++) {
			for( j = x-1<0?0:x-1; j <= x+1 && j < width; j++) {
				if( map[i][j] < itemCode[0] ) {	// 아이템이 아니면
						clear[i][j] = 1;
						map[i][j] = blankNumber;
						clicked[i][j] = 0;
				}
			}
		}
		clear[y][x] = 1;
		map[y][x] = blankNumber;
		clicked[y][x] = 0;
		return;	// 클리어 하지 않는다
	}
	
	map[y][x] = blankNumber;
	clear[y][x] = 1;
	clicked[y][x] = 0;
}

function hintTimer()
{
	if( alwaysHint == false )
		hintFlag = false;
}

function increaseOneTile(i,j)
{
	if( map[i][j] >= kindOfNumber )
		return;
	map[i][j] = ( map[i][j] + 1 ) % kindOfNumber;
	if( clickOnce == true ) {
		if( clicked[i][j] == 0)
			clicked[i][j] = 999;
	}
}

function increaseWholeTile(number)
{
	var i,j;
		for( i = 0; i < height; i++) {
			for( j = 0; j < width; j++) {
				if( map[i][j] == number )
				{
					map[i][j] = ( parseInt(number) + 1 ) % kindOfNumber;
					if( clickOnce == true ) {
						if( clicked[i][j] == 0)
							clicked[i][j] = 999;
					}

				}
			}
		}
}

function increaseChainedTile(i,j,number)
{
	if( i < 0 || i >= height )
		return;
	if( j < 0 || j >= width )
		return;

	if( map[i][j] == number )
	{
		if( onetimeGrow == true && clicked[i][j] != 0 )
			return;
		map[i][j] = (map[i][j] + 1)%kindOfNumber;

		if( clickOnce == true ) {
			if( clicked[i][j] == 0)
				clicked[i][j] = 999;
		}
	}
	else
		return;

	increaseChainedTile(i-1,j,number);
	increaseChainedTile(i,j+1,number);
	increaseChainedTile(i+1,j,number);
	increaseChainedTile(i,j-1,number);
}

function clearChainedTile(i,j,number)
{
	if( i < 0 || i >= height )
		return;
	if( j < 0 || j >= width )
		return;

	if( map[i][j] == number )
	{
		map[i][j] = kindOfNumber;
		clear[i][j] = number;
	}
	else
		return;

	clearChainedTile(i-1,j,number);
	clearChainedTile(i+1,j,number);
	clearChainedTile(i,j-1,number);
	clearChainedTile(i,j+1,number);
}

function animate()
{
	if( inputEnable == true )
		return;

	if( aniState == 0 )
	{
		seq = 0;
		clearHint();
		checkComplete();

		var cleared = clearComleteTileByChunck();

		if( cleared == true ) {
			clearTimeout(comboTimingTid);
			if( gameMode != 3) {
				combo++;
				for(var i = 0; i < itemCreationTimingForCombo.length;i++)
					if( itemCreationTimingForCombo[i] == combo ) {
						itemCreationFlag = false;//true;
						feverLevel = i + 1;
						if( feverLevel > maxFever )
							maxFever = feverLevel;
						break;
					}
			}
			if( combo > maxComboOnGame )
				maxComboOnGame = combo;
		}
		else{
			if( gameMode != 0 && gameMode != 3) {
				combo = 0;
				feverLevel = 0;
			}

			if( appleWatchMode == false )
			{
				makeHint();
				updateTile();
			}
		}

//		itemApplied = false;

		updateTile();
		if( isAllLanded() == true )
		{
			inputEnable = true;
			clearInterval(animateTid);

			var i,j;
			var clickable = false;
			for(i = 0; i < height; i++){
				for(j = 0;j<width;j++) {
					if( clicked[i][j] == 0 )
						clickable = true;
				}
			}

			if( clickable == false )
			{
				gameOver();
				return;
			}
		}
		else
		{
			aniState = 1;
			//setTimeout("animate()", 500);
		}


		return;
	}
	if( aniState == 1 )
	{
		dropTile();
		updateTile();
		if( isAllLanded() == true )
		{
			aniState = 2;
			//setTimeout("animate()", 500);
		}

		return;
	}
	if( aniState == 2 )
	{
		checkComplete();
		var cleared = clearComleteTileByChunck();
		if( cleared == true ) {
			seq++;
			if( seq > seqMax )
				seqMax = seq;
			clearTimeout(comboTimingTid);

			if( gameMode != 3 ) {
				combo++;
				for(var i = 0; i < itemCreationTimingForCombo.length;i++)
					if( itemCreationTimingForCombo[i] == combo ) {
						itemCreationFlag = false;//true;
						feverLevel = i + 1;
						if( feverLevel > maxFever )
							maxFever = feverLevel;
					}
			}
			if( combo > maxComboOnGame )
				maxComboOnGame = combo;
		}

		if( isAllLanded() == true )
		{
			inputEnable = true;

			clearInterval(animateTid);
			comboTimingTid = setTimeout("comboInvalid()", comboTiming);

			if( hintFlag == true )
			{
				makeHint();
				updateTile();
			}

			aniState = 0;

			var i,j;
			var clickable = false;
			for(i = 0; i < height; i++){
				for(j = 0;j<width;j++) {
					if( clicked[i][j] == 0 )
						clickable = true;
				}
			}

			if( clickable == false )
			{
				gameOver();
				return;
			}

		}
		else
		{
			updateTile();
			aniState = 1;

			//setTimeout("animate()", 500);
		}
			if( gameTimeResetEveryClick == true )
			remainTime = gameTime;

		return;
	}
}

function comboInvalid()
{
	combo = 0;
	feverLevel = 0;
	if(appleWatchMode == false )
	{
		makeHint();
		updateTile();
	}
}

function checkComplete()
{
	var i,j,k;
	if( gameMode == 3 )
		return;
	var row = new Array(width);

	var prev, count;
	for(i = 0; i < height; i++)	{
		count = 1;
		prev = -1;
		for(j = 0; j < width; j++) {
			if( map[i][j] == prev && map[i][j] < blankNumber)	// blank는 아이템이었던 경우이므로 제외한다
				count++;
			else
				count = 1;
			row[j] = count;
			prev = map[i][j];
		}

		for( j = width-1; j > -1; j--) {
			if( row[j] >= minOfComplete)
			{
				for( k = 0; k < row[j]; k++)
					clear[i][j - k] = row[j];

				j = j - row[j] + 1;
			}
		}
	}

	var column = new Array(height);

	for(j = 0; j < width; j++)	{
		count = 1;
		prev = -1;
		for(i = 0; i < height; i++) {
			if( map[i][j] == prev && map[i][j] < blankNumber )
				count++;
			else
				count = 1;
			column[i] = count;
			prev = map[i][j];
		}

		for( i = height-1; i > -1; i--) {
			if( column[i] >= minOfComplete)
			{
				for( k = 0; k < column[i]; k++)
					clear[i - k][j] = column[i];

				i = i - column[i] + 1;
			}
		}
	}
}

function clearCompleteRec(x,y,count)
{
	if( x < 0 || x >= width )
		return count;
	if( y < 0 || y >= height )
		return count;

	if( clear[y][x] == 0 )
		return count;

	clear[y][x] = 0;
	map[y][x] = blankNumber;
	clicked[y][x] = 0;

	count++;

	count = clearCompleteRec(x,y-1,count);
	count = clearCompleteRec(x+1,y,count);
	count = clearCompleteRec(x,y+1,count);
	count = clearCompleteRec(x-1,y,count);
	
	return count;
}

function clearComleteTileByChunck()
{
	var i,j;
	var cleared = false;
	var clearCount = 0;

	for(i = 0;i < height; i++) {
		for( j = 0; j < width; j++) {
			if( clear[i][j] != 0 ) {
				var count = clearCompleteRec(j,i,0);
				clearCount += count;
				cleared = true;

				var earn = 10 * count;
				earn = earn + (earn * combo);
				earn = earn + earn * ( feverLevel + 1);

				lastEarnedScore = lastEarnedScore + earn;
				if( gameMode != 3) {
					score = Math.floor( score + earn );
				}

				if( itemApplied == false ) {
					map[i][j] = itemForChunkAmount[ count ];
					if( count >= itemForChunkAmount.length )
						map[i][j] = itemForChunkAmount[itemForChunkAmount.length - 1];
				}
			}
		}
	}

	return cleared;
}

function clearCompleteTile()
{
	var i,j;
	var cleared = false;
	var clearCount = 0;

	for(i = 0; i < height; i++)
	{
		for(j = 0; j < width; j++)
		{
			if( clear[i][j] != 0 )
			{
				var earn = 10 * clear[i][j];	// TODO 점수 계산을 덩어리 단위로 바꿀 것
				earn = earn + (earn * combo);

				lastEarnedScore = lastEarnedScore + earn;
				if( gameMode != 3) {
					score = Math.floor( score + earn );
				}
				map[i][j] = blankNumber;
				clear[i][j] = 0;
				clicked[i][j] = 0;
				cleared = true;
				clearCount++;
			}
		}
	}
 
	if( gameMode == 3 ) {
		var earn = 10 * clearCount;
		score = Math.floor( score + earn + earn * combo );
		if( clearCount == width*height)
			combo++;
		else if( clearCount > 0 )
			combo = 0;
	}

	updateInfo();
	return cleared;
}

function updateTile()
{
	var i,j;
		for( i = 0; i < height; i++) {
			for( j = 0; j < width; j++) {
				var id = i * width + j;
				if( clicked[i][j] != 0 ) {
					 //$("#"+id).attr("value", map[i][j]).attr("style", "background-color:"+clickedColor).html(tileText[map[i][j]]);
					 $("#"+id).attr("value", map[i][j]).attr("style", "background-color:"+clickedColor).html(tileClickedText[map[i][j]]);
				}
				else {
					if( map[i][j] == blankNumber )	// 빈칸
						$("#"+id).attr("value", map[i][j]).attr("style", "background-color:"+color[map[i][j]]).html("<h1></h1>");
					else if( map[i][j] >= itemCode[0] ) {	// 아이템
						var itemIndex = map[i][j]-itemCode[0];
						$("#"+id).attr("value", map[i][j]).attr("style", "background-color:"+itemColor[itemIndex]).html(itemText[itemIndex]);
					}
					else {	// 일반 타일
						if( hintMap[i][j] == 1 )
							$("#"+id).attr("value", map[i][j]).attr("style", "background-color:"+hintColor).html(tileText[map[i][j]]);
						else
							$("#"+id).attr("value", map[i][j]).attr("style", "background-color:"+color[map[i][j]]).html(tileText[map[i][j]]);
					}

				}
			}
		}

		updateInfo();
}

function updateInfo()
{
		$("#combo").html(combo);
		$("#score").html(score);
		$("#earned").html(lastEarnedScore);
		$("#maxComboOnGame").html(maxComboOnGame);
		$("#fever").html(feverLevel);


		$("#maxCombo").html(maxCombo);
		$("#highScore").html(highScore);
		$("#maxFever").html(maxFever);

		$("#log").html(seq + "/" + seqMax);
}

function displayGameTime()
{
	remainTime++;
	$("#remainTime").html(remainTime);

	if( remainTime < 0 && combo == 0 )//&& finalFlag == true)
	{
		if( appleWatchMode == true )
		{
			var i,j;
			var count = 0;
			for(i = 0; i < height; i++){
				for(j = 0;j<width;j++) {
					if( clicked[i][j] == 0 )
						count++;
				}
			}

			if( count < 2 )
			{
				clearInterval(remainTimeTid);
				setTimeout("gameOver()", 200 );
			}
			else
			{
				// 랜덤블럭 disable
				var num = Math.floor(Math.random()*(width*height));
				var pick = -1;
				i = 0;
				while(true)
				{
					var y = Math.floor(i/height);
					if( clicked[y][i%width] == 0 )
					{
						pick++;
					}
					if( pick == num )
					{
						if( clicked[y][i%width] == 0 ) {
							clicked[y][i%width] = 999;
						}
						if( gameTimeResetEveryClick == true )
							remainTime = gameTime;

						updateTile();
						break;
					}
					i++;
					if( i >= (width*height) )
						i = 0;
				}
			}
		}
		else
		{
			clearInterval(remainTimeTid);
			setTimeout("gameOver()", 200 );
		}
	}
}

/*
	타일 한칸 아래로 떨어트림
*/
function dropTileWithRegen()
{
	if( dropBlock == false ) {
		for( i = 0; i < height; i++)
		{
			for( j = 0; j < width; j++)
			{
				if( map[i][j] == blankNumber )
				{
					var tile = createOneTile(j, i);
					map[i][j] = tile;
					clicked[i][j] = 0;
				}
			}
		}
		return;
	}

	var i,j;
	for( i = height - 1; i >= 0; i--) {
		for( j = 0; j < width; j++ ) {
			if( map[i][j] == blankNumber ) {
				var upper = blankNumber;
				var upperClicked = 0;
				if( i == 0 ) {
					upper = createOneTile(j,i);
					upperClicked = 0;
				}
				else {
					upper = map[i-1][j];
					upperClicked = clicked[i-1][j];
					map[i-1][j] = blankNumber;
					clicked[i-1][j] = 0;
				}
				
				map[i][j] = upper;
				clicked[i][j] = upperClicked;
			}
		}
	}
}

function dropTile()
{
	if( dropBlock == false ) {
		for( i = 0; i < height; i++)
		{
			for( j = 0; j < width; j++)
			{
				if( map[i][j] == blankNumber )
				{
					var tile = createOneTile(j, i);
					map[i][j] = tile;
					clicked[i][j] = 0;
				}
			}
		}
		return;
	}

	var i,j;
	for( i = height - 1; i >= 0; i--) {
		for( j = 0; j < width; j++ ) {
			if( map[i][j] == blankNumber ) {
				var upper = blankNumber;
				var upperClicked = 0;
				if( i == 0 ) {
					if( regenBlock == true ) {
						upper = createOneTile(j,i);
						upperClicked = 0;
					}
				}
				else {
					upper = map[i-1][j];
					upperClicked = clicked[i-1][j];
					map[i-1][j] = blankNumber;
					clicked[i-1][j] = 0;
				}
				
				map[i][j] = upper;
				clicked[i][j] = upperClicked;
			}
		}
	}
}

function createOneTile(x,y)
{
	var r = Math.floor(Math.random()*1000);
	if( /*r < itemChanceMax || */itemCreationFlag == true && 0) {
		var chance = Math.floor(Math.random()*itemChanceTotal);
		for(var i=0; i<itemPortion.length; i++) {
			if( chance < itemPortion[i] ) {
				itemCreationFlag = false;
				return itemCode[i];
			}
		}
	}
	/*
		놓일 위치의 좌,우,하단 블럭 검사해서 중복되지 않는 블럭 생성
		좌, 우 체크가 정확하게 되지 않기 때문에 3x3게임의 경우 전체 타일 두종류 이상 검사가 반드시 필요하다.
		2015.08.09
	*/

	if(appleWatchMode == false ) {
		var i;
		if( dropBlock == true ) {
			for( i = 0; i < height; i++)
			{
				if(map[i][x] != blankNumber )
				{
					y = i - 1;
					break;
				}
			}
		}

		var check = new Array(kindOfNumber);
		for( i=0;i<kindOfNumber;i++)
			check[i]=0;
		
		if(dropBlock == false ){
			if( x > 0 ) {
				if( map[y][x-1] < kindOfNumber )
					check[map[y][x-1]] = 1;
			}
			if( x < (width -1) ) {
				if( map[y][x+1] < kindOfNumber )
					check[map[y][x+1]] = 1;
			}
		}
		else{
			// 이 부분 추가할 경우 난이도가 두배(점수기준)로 증가함 2015.08.10
			if( y < (height -1 ) ) {
				if( map[y+1][x] < kindOfNumber )
					check[map[y+1][x]] = 1;
			}
		}
		var num = Math.floor(Math.random()*(kindOfNumber));
		var pick = -1;

		i = 0;
		while(true)
		{
			if( check[i] == 0 )
			{
				pick++;
			}
			if( pick == num )
				return i;

			i++;
			if( i >= kindOfNumber )
				i = 0;
		}
	}

	// 3x3일 게임의 경우 반드시 필요한 로직임.
	// 전체 타일의 타입이 두 종류 이하가 되지 않도록 하기 위한 부분
	//	타일 생성, 삭제시 타입 수를 카운트하도록 하면 여기서 매번 전체 검색을 하지 않아도 됨
	//	2015.08.09
	//

	// 전체 타일의 타입 갯수 체크
	var i, j;
	var count = 0;
	var check = new Array(kindOfNumber);
	for( i=0;i<kindOfNumber;i++)
		check[i]=0;
	for( i=0;i<height;i++) {
		for(j=0;j<width;j++) {
			if( map[i][j] < kindOfNumber )
			{
				if( check[map[i][j]] == 0 )
					count++;
				check[map[i][j]] = 1;
			}
		}
	}
	// 전체 타일의 타입 갯수가 두 종류 이하일 경우 없는 종류를 생성
	if( count < 3 )
	{
		var num = Math.floor(Math.random()*(kindOfNumber-count));
		var pick = -1;
		for(i=0;i<kindOfNumber;i++)
		{
			if( check[i] == 0 )
			{
				pick++;
				if( pick == num )
				{
					return i;
				}
			}
		}
	}

	// 일반적인 경우
	return Math.floor(Math.random()*kindOfNumber);
}

function isAllLanded() {
	var i,j;
	for( i=0; i<height-1; i++){
		for( j=0; j<width; j++){
			if( map[i][j] != blankNumber) {
				if( map[i+1][j] == blankNumber) {
					return false;
				}
			}
		}
	}
	return true;
}


function isFilled()
{
	var i,j;
	for(i=0;i<height;i++){
		for(j=0;j<width;j++){
			if( map[i][j]==blankNumber)
				return false;
		}
	}
	return true;
}

function gameOver()
{
	if( inputEnable == false )
	{
		setTimeout("gameOver()", 200);
		return;
	}
	clearInterval(animateTid);
	clearInterval(remainTimeTid);

	if( score > highScore )
	{
		highScore = score;
		alert("High Score!!! : " + score );
	}
	else
		alert("Score : " + score );
	if( maxComboOnGame > maxCombo ) {
		maxCombo = maxComboOnGame;
		alert("Max Combo!!! : " + maxComboOnGame );
	}
	else
		alert("Combo : " + maxComboOnGame);

	//alert("Ready?");
	//initGame();
}

function calcMapID() {
    var id = 0;
    var i = 0;
    for( var y = 0; y < height; y++) {
        for( var x = 0; x < width; x++ ) {
            id = id + map[y][x] * Math.pow( kindOfNumber, i );
            i++;
        }
    }
    return id;
}

function createNewBoardWithID(id, click) {
    var i = width * height - 1;
	
    for( var y = height - 1; y >= 0; y-- ) {
        for( var x = width - 1; x >= 0; x-- ) {
            var value = id / Math.pow( kindOfNumber, i );
			value = Math.floor(value);
            map[y][x] = value;
			hintMap[y][x] = 0;
			clear[y][x] = 0;
			
            id = id - value * Math.pow( kindOfNumber, i );
            i--;
        }
    }

	for( var y = 0; y < height; y++ ) {
		for( var x = 0; x < width; x++ ) {
			var disable = click / Math.pow( 10, width * height - (x + y * width) - 1);
			disable = Math.floor(disable);
			clicked[y][x] = disable;

			click = click - disable * Math.pow( 10, width * height - (x + y * width) - 1);
		}
	}
}


function initGame(id, click )
{
	var i,j;
	score = 0;
	lastEarnedScore = 0;
	combo = 0;
	comboTiming = 1500;
	finalFlag = false;
	maxComboOnGame = 0;
	seqMax = 0;

	for( i = 0; i < itemChance.length; i++) {
		itemChanceTotal += itemChance[i];
		itemPortion[i] = itemChanceTotal;
		if( itemChance[i] > itemChanceMax )
			itemChanceMax = itemChance[i];
	}

	for( i = 0; i < height; i++)
	{
		map[i] = new Array(width);
		hintMap[i] = new Array(width);
		clear[i] = new Array(width);
		clicked[i] = new Array(width);
	}

	if( id == 0 ) {
		for( i = 0; i < height; i++) {
			for( j = 0; j < width; j++) {
				map[i][j] = Math.floor((Math.random()*kindOfNumber));
				hintMap[i][j] = 0;
				clear[i][j] = 0;
				clicked[i][j] = 0;
			}
		}

		checkComplete();
		clearCompleteTile();

		while(isFilled()==false) {
			while(isFilled()==false) {
				dropTileWithRegen();
				updateTile();
			}
			checkComplete();
			clearCompleteTile();
		}
	} else {
		createNewBoardWithID(id, click);
	}

	inputEnable = true;
	aniState = 0;
	remainTime = gameTime;

	score = 0;
	lastEarnedScore = 0;
	combo = 0;
	maxComboOnGame = 0;

	updateTile();

	remainTimeTid = setInterval("displayGameTime()", 1000 );
	
	id = calcMapID();
	return id;
}

function decrease()
{
	var i,j;
	for(i = 0; i<height; i++){
		for(j = 0; j < width; j++){
			if( map[i][j] == (kindOfNumber-1) )
				map[i][j]--;
		}
	}
	updateTile();
}


</script>
</head>

<body>
<div>
ID : <input id="mapid" type="text" value="0">
<input id="clickmap" type="text" value="0"><br>
<input id="generate" type="button" value="Generate">
<input id="random" type="button" value="Random">
</div>
<div id="info">
Time : <span id="remainTime">0</span><br>
Score : <span id="score">0</span>
Max Combo : <span id="maxComboOnGame">0</span>
Current : <span id="earned">0</span>
Combo : <span id="combo">0</span>
Fever: <span id="fever">0</span>
</div>
<div id="gameDiv">
<table id="game" border=0>
</table>
</div>
<div id="history">
High Score : <span id="highScore">0</span>
Max Combo : <span id="maxCombo">0</span>
Max Fever: <span id="maxFever">0</span>
</div>
<textarea id="log" rows=10 cols=80></textarea>
</body>
</html>